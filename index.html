<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Fidelity Xmas Tree</title>
    <style>
        body { margin: 0; background: #020504; overflow: hidden; font-family: -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        .overlay {
            position: absolute; top: 10%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }
        .overlay h1 { color: #FFFACD; text-shadow: 0 0 20px rgba(255,250,205,0.8); margin: 0; font-size: 28px; min-height: 1.2em; }
        .overlay p { color: white; opacity: 0.6; letter-spacing: 5px; font-size: 12px; margin-top: 10px; }
        .hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #C1E1C1; opacity: 0.5; font-size: 11px; letter-spacing: 2px; pointer-events: none;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom": "https://esm.sh/react-dom@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.15?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.11?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div class="overlay">
        <h1 id="greeting"></h1>
        <p>MERRY CHRISTMAS</p>
    </div>
    <div id="root"></div>
    <div class="hint">点击触发粒子爆发 • 拖拽旋转视角</div>

    <script type="text/babel" data-type="module">
        /** @jsx React.createElement */
        /** @jsxFrag React.Fragment */
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Float, Stars, OrbitControls, PerspectiveCamera, MeshWobbleMaterial } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

        // 调色板
        const PALETTE = {
            green: '#1A3317', 
            gold: '#FFD700', 
            silver: '#E5E4E2',
            xmasRed: '#D42426',
            xmasGreen: '#165B33',
            pink: '#FFB7B2',
            bg: '#020504'
        };

        // 打字机效果
        const Typewriter = () => {
            useEffect(() => {
                const text = "小羊同学，圣诞节快乐！";
                let i = 0;
                const interval = setInterval(() => {
                    const el = document.getElementById('greeting');
                    if(el) el.innerText = text.slice(0, i);
                    i++;
                    if (i > text.length) clearInterval(interval);
                }, 150);
                return () => clearInterval(interval);
            }, []);
            return null;
        };

        // 雪花系统
        const Snow = ({ count = 1000 }) => {
            const mesh = useRef();
            const [particles] = useMemo(() => {
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    pos.set([(Math.random()-0.5)*30, Math.random()*25, (Math.random()-0.5)*30], i * 3);
                }
                return [pos];
            }, [count]);

            useFrame(() => {
                const positions = mesh.current.geometry.attributes.position.array;
                for (let i = 0; i < count; i++) {
                    positions[i * 3 + 1] -= 0.03;
                    if (positions[i * 3 + 1] < -5) positions[i * 3 + 1] = 20;
                }
                mesh.current.geometry.attributes.position.needsUpdate = true;
            });

            return (
                <points ref={mesh}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={particles} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.06} color="#ffffff" transparent opacity={0.6} />
                </points>
            );
        };

        // 礼物盒组件
        const GiftBox = ({ position, color, ribbonColor, scale = 1 }) => (
            <group position={position} scale={scale}>
                <mesh castShadow>
                    <boxGeometry args={[1, 1, 1]} />
                    <meshStandardMaterial color={color} roughness={0.5} />
                </mesh>
                <mesh position={[0, 0, 0]}>
                    <boxGeometry args={[1.05, 0.2, 1.05]} />
                    <meshStandardMaterial color={ribbonColor} />
                </mesh>
                <mesh position={[0, 0, 0]} rotation={[0, 0, Math.PI/2]}>
                    <boxGeometry args={[1.05, 0.2, 1.05]} />
                    <meshStandardMaterial color={ribbonColor} />
                </mesh>
            </group>
        );

        // 线条兔子 (几何风格)
        const WireRabbit = ({ isExploded }) => {
            const groupRef = useRef();
            const [data] = useMemo(() => {
                const temp = [];
                for(let i=0; i<6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    temp.push({
                        pos: [Math.cos(angle)*3, -3.8, Math.sin(angle)*3],
                        rot: [0, -angle, 0]
                    });
                }
                return [temp];
            }, []);

            useFrame((state) => {
                if(!isExploded) {
                    groupRef.current.rotation.y += 0.005;
                }
            });

            return (
                <group ref={groupRef} visible={!isExploded}>
                    {data.map((d, i) => (
                        <group key={i} position={d.pos} rotation={d.rot}>
                            {/* 兔子身体 */}
                            <mesh>
                                <icosahedronGeometry args={[0.3, 1]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            {/* 兔子耳朵 */}
                            <mesh position={[0.1, 0.4, 0]} rotation={[0, 0, 0.2]}>
                                <capsuleGeometry args={[0.05, 0.3, 2, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            <mesh position={[-0.1, 0.4, 0]} rotation={[0, 0, -0.2]}>
                                <capsuleGeometry args={[0.05, 0.3, 2, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                        </group>
                    ))}
                </group>
            );
        };

        // 实例化金属球
        const MetallicOrbs = ({ isExploded }) => {
            const meshRef = useRef();
            const dummy = new THREE.Object3D();
            const count = 40;
            const colors = [PALETTE.gold, PALETTE.silver, PALETTE.xmasRed, '#00A86B'];

            const orbs = useMemo(() => {
                const temp = [];
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 0.9) * 9 - 4.5;
                    const r = (5 - y) * 0.4;
                    const angle = Math.random() * Math.PI * 2;
                    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                    temp.push({
                        basePos: pos.clone(),
                        currentPos: pos.clone(),
                        velocity: pos.clone().normalize().multiplyScalar(Math.random() * 10 + 5),
                        color: new THREE.Color(colors[i % colors.length])
                    });
                }
                return temp;
            }, []);

            useFrame((state, delta) => {
                orbs.forEach((o, i) => {
                    if (isExploded) {
                        o.currentPos.addScaledVector(o.velocity, delta * 0.5);
                    } else {
                        o.currentPos.lerp(o.basePos, 0.1);
                    }
                    dummy.position.copy(o.currentPos);
                    dummy.scale.setScalar(1.2);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                    meshRef.current.setColorAt(i, o.color);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                meshRef.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[new THREE.SphereGeometry(0.12, 24, 24), null, count]}>
                    <meshStandardMaterial metalness={1} roughness={0.1} />
                </instancedMesh>
            );
        };

        // 树叶粒子
        const FoliageLayer = ({ isExploded }) => {
            const count = 4000;
            const meshRef = useRef();
            const pts = useMemo(() => {
                const arr = new Float32Array(count * 3);
                const vels = new Float32Array(count * 3);
                const base = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 1.1) * 10 - 5;
                    const r = (5 - y) * 0.42;
                    const a = Math.random() * Math.PI * 2;
                    const x = Math.cos(a) * r, z = Math.sin(a) * r;
                    arr.set([x, y, z], i * 3); base.set([x, y, z], i * 3);
                    const vel = new THREE.Vector3(x, y, z).normalize().multiplyScalar(Math.random() * 15 + 5);
                    vels.set([vel.x, vel.y, vel.z], i * 3);
                }
                return { arr, vels, base };
            }, []);

            useFrame((state, delta) => {
                const attr = meshRef.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    let x = attr.array[i*3], y = attr.array[i*3+1], z = attr.array[i*3+2];
                    if (isExploded) {
                        x += pts.vels[i*3] * delta * 0.5; y += pts.vels[i*3+1] * delta * 0.5; z += pts.vels[i*3+2] * delta * 0.5;
                    } else {
                        x = THREE.MathUtils.lerp(x, pts.base[i*3], 0.1);
                        y = THREE.MathUtils.lerp(y, pts.base[i*3+1], 0.1);
                        z = THREE.MathUtils.lerp(z, pts.base[i*3+2], 0.1);
                    }
                    attr.setXYZ(i, x, y, z);
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={pts.arr} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.07} color="#165B33" transparent opacity={0.8} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        const App = () => {
            const [exploded, setExploded] = useState(false);

            return (
                <Canvas onClick={() => setExploded(!exploded)}>
                    <Typewriter />
                    <PerspectiveCamera makeDefault position={[0, 2, 16]} fov={45} />
                    <OrbitControls enablePan={false} autoRotate={!exploded} autoRotateSpeed={0.5} minDistance={8} maxDistance={20} />
                    
                    <color attach="background" args={[PALETTE.bg]} />
                    <ambientLight intensity={0.5} />
                    <pointLight position={[10, 10, 10]} intensity={10} color={PALETTE.gold} />
                    <spotLight position={[0, 10, 0]} intensity={5} color="#ffffff" angle={0.5} />

                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade />
                    <Snow count={1200} />

                    <FoliageLayer isExploded={exploded} />
                    <MetallicOrbs isExploded={exploded} />
                    <WireRabbit isExploded={exploded} />

                    {/* 树下的礼物盒 */}
                    {!exploded && (
                        <group position={[0, -4.5, 0]}>
                            <GiftBox position={[2, 0, 1]} color={PALETTE.xmasRed} ribbonColor={PALETTE.gold} scale={0.8} />
                            <GiftBox position={[-1.5, 0, 2]} color="#4169E1" ribbonColor="#ffffff" scale={1} />
                            <GiftBox position={[0.5, 0, -2.5]} color={PALETTE.xmasGreen} ribbonColor={PALETTE.pink} scale={0.7} />
                        </group>
                    )}

                    {/* 顶部发光星 */}
                    <Float speed={3} rotationIntensity={2} floatIntensity={1}>
                        <mesh position={[0, 5.4, 0]}>
                            <octahedronGeometry args={[0.5, 0]} />
                            <meshBasicMaterial color={PALETTE.gold} />
                            <pointLight intensity={20} distance={10} color={PALETTE.gold} />
                        </mesh>
                    </Float>

                    <EffectComposer>
                        <Bloom luminanceThreshold={0.2} mipmapBlur intensity={1.5} radius={0.4} />
                        <Vignette offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </Canvas>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
