<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Fidelity Xmas Tree</title>
    <style>
        body { margin: 0; background: #050a07; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        .overlay {
            position: absolute; top: 12%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }
        .overlay h1 { 
            color: #FFFACD; 
            text-shadow: 0 0 20px rgba(255, 250, 205, 0.5); 
            margin: 0; font-size: 28px; 
            min-height: 1.2em;
        }
        .overlay p { color: white; opacity: 0.5; letter-spacing: 5px; font-size: 12px; margin-top: 8px; }
        .hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #C1E1C1; opacity: 0.4; font-size: 11px; letter-spacing: 2px; pointer-events: none;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.15?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.11?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div class="overlay">
        <h1 id="title"></h1>
        <p>MERRY CHRISTMAS</p>
    </div>
    <div id="root"></div>
    <div class="hint">点击屏幕触发粒子爆发 • 拖动旋转</div>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Float, Stars, OrbitControls, PerspectiveCamera } from '@react-three/drei';
        import { EffectComposer, Bloom, Noise, Vignette } from '@react-three/postprocessing';

        const PALETTE = { green: '#2D5A27', pink: '#FADADD', gold: '#FFFACD', accent: '#FFB7B2', bg: '#020504' };

        // --- 打字机效果 ---
        const Typewriter = () => {
            useEffect(() => {
                const text = "小羊同学，圣诞节快乐！";
                const el = document.getElementById('title');
                let i = 0;
                const timer = setInterval(() => {
                    el.innerHTML = text.slice(0, i);
                    i++;
                    if (i > text.length) clearInterval(timer);
                }, 150);
                return () => clearInterval(timer);
            }, []);
            return null;
        };

        // --- 雪花组件 ---
        const Snow = ({ count = 800 }) => {
            const meshRef = useRef();
            const [positions, velocities] = useMemo(() => {
                const pos = new Float32Array(count * 3);
                const vel = new Float32Array(count);
                for (let i = 0; i < count; i++) {
                    pos.set([(Math.random() - 0.5) * 25, Math.random() * 20 - 5, (Math.random() - 0.5) * 25], i * 3);
                    vel[i] = Math.random() * 0.02 + 0.01;
                }
                return [pos, vel];
            }, [count]);

            useFrame(() => {
                const attr = meshRef.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    attr.array[i * 3 + 1] -= velocities[i];
                    if (attr.array[i * 3 + 1] < -7) attr.array[i * 3 + 1] = 13;
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={positions} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.04} color="#ffffff" transparent opacity={0.4} />
                </points>
            );
        };

        const OrnamentLayer = ({ count, geometry, color, isExploded, wireframe = false, scale = 1 }) => {
            const meshRef = useRef();
            const dummy = new THREE.Object3D();
            const particles = useMemo(() => {
                const temp = [];
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 0.9) * 10 - 5;
                    const r = (5 - y) * 0.45;
                    const angle = Math.random() * Math.PI * 2;
                    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                    temp.push({
                        basePos: pos.clone(),
                        baseRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                        currentPos: pos.clone(),
                        currentRot: new THREE.Euler().copy(new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0)),
                        velocity: pos.clone().normalize().multiplyScalar(Math.random() * 12 + 4),
                        angVel: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, 0).multiplyScalar(2)
                    });
                }
                return temp;
            }, [count]);

            useFrame((state, delta) => {
                particles.forEach((p, i) => {
                    if (isExploded) {
                        p.currentPos.addScaledVector(p.velocity, delta * 0.6);
                        p.currentRot.x += p.angVel.x * delta;
                        p.currentRot.y += p.angVel.y * delta;
                        p.velocity.multiplyScalar(0.97);
                    } else {
                        p.currentPos.lerp(p.basePos, 0.1);
                        p.currentRot.x = THREE.MathUtils.lerp(p.currentRot.x, p.baseRot.x, 0.1);
                        p.currentRot.y = THREE.MathUtils.lerp(p.currentRot.y, p.baseRot.y, 0.1);
                    }
                    dummy.position.copy(p.currentPos);
                    dummy.rotation.copy(p.currentRot);
                    dummy.scale.setScalar(scale);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[geometry, null, count]}>
                    <meshStandardMaterial color={color} roughness={0.1} metalness={0.8} wireframe={wireframe} emissive={color} emissiveIntensity={wireframe ? 2 : 0.5} />
                </instancedMesh>
            );
        };

        const FoliageLayer = ({ isExploded }) => {
            const count = 4000;
            const meshRef = useRef();
            const pts = useMemo(() => {
                const arr = new Float32Array(count * 3);
                const vels = new Float32Array(count * 3);
                const base = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 1.1) * 10 - 5;
                    const r = (5 - y) * 0.42;
                    const a = Math.random() * Math.PI * 2;
                    const x = Math.cos(a) * r, z = Math.sin(a) * r;
                    arr.set([x, y, z], i * 3);
                    base.set([x, y, z], i * 3);
                    const vel = new THREE.Vector3(x, y, z).normalize().multiplyScalar(Math.random() * 15 + 5);
                    vels.set([vel.x, vel.y, vel.z], i * 3);
                }
                return { arr, vels, base };
            }, []);

            useFrame((state, delta) => {
                const attr = meshRef.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    let x = attr.array[i*3], y = attr.array[i*3+1], z = attr.array[i*3+2];
                    if (isExploded) {
                        x += pts.vels[i*3] * delta * 0.5;
                        y += pts.vels[i*3+1] * delta * 0.5;
                        z += pts.vels[i*3+2] * delta * 0.5;
                    } else {
                        x = THREE.MathUtils.lerp(x, pts.base[i*3], 0.1);
                        y = THREE.MathUtils.lerp(y, pts.base[i*3+1], 0.1);
                        z = THREE.MathUtils.lerp(z, pts.base[i*3+2], 0.1);
                    }
                    attr.setXYZ(i, x, y, z);
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={pts.arr} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.06} color="#4ade80" transparent opacity={0.8} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        const App = () => {
            const [exploded, setExploded] = useState(false);
            const boxGeo = useMemo(() => new THREE.BoxGeometry(0.2, 0.2, 0.2), []);
            const sphereGeo = useMemo(() => new THREE.SphereGeometry(0.12, 16, 16), []);
            const starGeo = useMemo(() => new THREE.IcosahedronGeometry(0.15, 0), []);

            return (
                <Canvas onClick={() => setExploded(!exploded)} dpr={[1, 2]}>
                    <Typewriter />
                    <PerspectiveCamera makeDefault position={[0, 2, 16]} fov={45} />
                    <OrbitControls enablePan={false} autoRotate={!exploded} autoRotateSpeed={0.5} maxDistance={25} minDistance={5} />
                    
                    <color attach="background" args={[PALETTE.bg]} />
                    <fog attach="fog" args={[PALETTE.bg, 10, 30]} />
                    
                    <ambientLight intensity={0.2} />
                    <pointLight position={[5, 5, 5]} intensity={5} color={PALETTE.gold} />
                    <spotLight position={[0, 10, 0]} intensity={2} angle={0.3} penumbra={1} color={PALETTE.pink} />

                    <Stars radius={100} depth={50} count={3000} factor={4} saturation={0} fade speed={1} />
                    <Snow count={1000} />
                    
                    <FoliageLayer isExploded={exploded} />

                    <OrnamentLayer count={40} geometry={boxGeo} color={PALETTE.accent} isExploded={exploded} scale={1.2} />
                    <OrnamentLayer count={60} geometry={sphereGeo} color={PALETTE.gold} isExploded={exploded} />
                    <OrnamentLayer count={30} geometry={starGeo} color={PALETTE.pink} isExploded={exploded} wireframe={true} scale={1.8} />

                    <Float speed={4} rotationIntensity={1.5} floatIntensity={2}>
                        <mesh position={[0, 5.5, 0]}>
                            <octahedronGeometry args={[0.5, 0]} />
                            <meshBasicMaterial color={PALETTE.gold} />
                            <pointLight intensity={10} distance={5} color={PALETTE.gold} />
                        </mesh>
                    </Float>

                    <EffectComposer disableNormalPass>
                        <Bloom luminanceThreshold={0.2} mipmapBlur intensity={1.5} radius={0.4} />
                        <Vignette eskil={false} offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </Canvas>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
