<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas</title>
    <style>
        body { margin: 0; background: #020504; overflow: hidden; font-family: -apple-system, sans-serif; user-select: none; -webkit-user-select: none; }
        #root { width: 100vw; height: 100vh; }
        
        /* --- 1. å¼€åœºé®ç½©å±‚ (æ‰‹æœºç«¯å¿…é¡») --- */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: white;
            transition: opacity 0.8s ease;
            backdrop-filter: blur(5px);
            cursor: pointer;
        }
        .start-content { text-align: center; animation: pulse 2s infinite; }
        .tap-icon { font-size: 40px; margin-bottom: 20px; display: block; }
        .start-text { font-size: 24px; font-weight: 300; letter-spacing: 2px; }
        .start-sub { font-size: 12px; opacity: 0.6; margin-top: 10px; letter-spacing: 1px; }

        @keyframes pulse { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.8; } 100% { transform: scale(1); opacity: 1; } }

        /* --- 2. 3Dåœºæ™¯æ–‡å­—å åŠ å±‚ --- */
        .overlay {
            position: absolute; top: 12%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }
        .overlay h1 { color: #FFFACD; text-shadow: 0 0 20px rgba(255,250,205,0.8); margin: 0; font-size: 28px; min-height: 1.2em; }
        .overlay p { color: white; opacity: 0.6; letter-spacing: 5px; font-size: 12px; margin-top: 10px; }
        
        .hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #C1E1C1; opacity: 0.5; font-size: 11px; letter-spacing: 2px; pointer-events: none;
            z-index: 5;
        }

        /* --- 3. è“ç²‰è‰²éŸ³ä¹æ’­æ”¾å™¨ (å³ä¸‹è§’) --- */
        #music-container {
            position: fixed;
            bottom: 30px;
            right: 20px;
            z-index: 9999;
            
            /* è“ç²‰æ¸å˜ + æ¯›ç»ç’ƒ */
            background: linear-gradient(135deg, rgba(161, 140, 209, 0.8) 0%, rgba(251, 194, 235, 0.8) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            
            padding: 8px 15px;
            border-radius: 50px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            
            display: flex; align-items: center; gap: 10px;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.27);
            
            /* åˆå§‹éšè—ï¼Œç‚¹å‡»åæ»‘å…¥ */
            opacity: 0;
            transform: translateY(50px);
        }

        #music-container.show { opacity: 1; transform: translateY(0); }

        .music-info { color: white; text-align: right; margin-right: 5px; }
        .music-title { font-size: 12px; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.1); display: block; }
        .music-status { font-size: 9px; opacity: 0.9; display: block; }

        .music-btn {
            width: 36px; height: 36px;
            border-radius: 50%; border: none;
            background: rgba(255, 255, 255, 0.4);
            color: white; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            -webkit-tap-highlight-color: transparent;
        }

        .spinning { animation: spin 4s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom": "https://esm.sh/react-dom@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.15?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.11?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>

    <div id="start-overlay" onclick="startExperience()">
        <div class="start-content">
            <span class="tap-icon">ğŸ‘†</span>
            <div class="start-text">ç‚¹å‡»å¼€å¯åœ£è¯æƒŠå–œ</div>
            <div class="start-sub">å»ºè®®ä½©æˆ´è€³æœº</div>
        </div>
    </div>

    <div id="music-container">
        <div class="music-info">
            <span class="music-title">Christmas Song</span>
            <span id="music-text" class="music-status">ç‚¹å‡»æ’­æ”¾</span>
        </div>
        <button id="music-toggle" class="music-btn">â–¶</button>
        <audio id="bgm-audio" loop playsinline preload="auto">
            <source src="song.mp3" type="audio/mpeg">
        </audio>
    </div>

    <div class="overlay">
        <h1 id="greeting"></h1>
        <p>MERRY CHRISTMAS</p>
    </div>
    <div id="root"></div>
    <div class="hint">äººç”Ÿä¸è¿‡ä¸‰ä¸‡å¤©ï¼Œæˆ‘æ„¿çˆ±ä½ ä¸‰ä¸‡é</div>

    <script>
        let isPlaying = false;

        function startExperience() {
            const overlay = document.getElementById('start-overlay');
            const player = document.getElementById('music-container');
            const audio = document.getElementById('bgm-audio');
            const btn = document.getElementById('music-toggle');
            const statusText = document.getElementById('music-text');

            // 1. ç§»é™¤é®ç½©
            overlay.style.opacity = '0';
            setTimeout(() => overlay.remove(), 800);

            // 2. æ˜¾ç¤ºæ’­æ”¾å™¨
            player.classList.add('show');

            // 3. ã€æ ¸å¿ƒä¿®æ”¹ã€‘å¼ºåˆ¶é‡ç½®éŸ³é¢‘æµ
            audio.volume = 1.0; // å¼ºåˆ¶éŸ³é‡ 100%
            audio.load();       // å¼ºåˆ¶æµè§ˆå™¨é‡æ–°è¯·æ±‚æ•°æ®
            
            // 4. å°è¯•æ’­æ”¾
            const playPromise = audio.play();

            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // æ’­æ”¾æˆåŠŸ
                    isPlaying = true;
                    btn.innerText = 'ğŸµ';
                    btn.classList.add('spinning');
                    statusText.innerText = 'æ­£åœ¨æ’­æ”¾';
                }).catch(error => {
                    // æ’­æ”¾å¤±è´¥
                    console.log("æ’­æ”¾å¤±è´¥:", error);
                    btn.innerText = 'â–¶';
                    statusText.innerText = 'ç‚¹å‡»æ’­æ”¾';
                });
            }
        }

        // æ’­æ”¾å™¨æŒ‰é’®äº¤äº’é€»è¾‘
        document.getElementById('music-toggle').addEventListener('click', function(e) {
            e.stopPropagation(); // é˜²æ­¢è§¦å‘èƒŒæ™¯ç‚¹å‡»
            const audio = document.getElementById('bgm-audio');
            const statusText = document.getElementById('music-text');
            
            if (audio.paused) {
                audio.play();
                this.innerText = 'ğŸµ';
                this.classList.add('spinning');
                statusText.innerText = 'æ­£åœ¨æ’­æ”¾';
            } else {
                audio.pause();
                this.innerText = 'â¸';
                this.classList.remove('spinning');
                statusText.innerText = 'å·²æš‚åœ';
            }
        });
    </script>

    <script type="text/babel" data-type="module">
        /** @jsx React.createElement */
        /** @jsxFrag React.Fragment */
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Float, Stars, OrbitControls, PerspectiveCamera } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

        // è°ƒè‰²æ¿
        const PALETTE = {
            green: '#1A3317', 
            gold: '#FFD700', 
            silver: '#E5E4E2',
            xmasRed: '#D42426',
            xmasGreen: '#165B33',
            pink: '#FFB7B2',
            bg: '#020504'
        };

        // æ‰“å­—æœºæ•ˆæœ
        const Typewriter = () => {
            useEffect(() => {
                const text = "å°ç¾ŠåŒå­¦ï¼Œåœ£è¯èŠ‚å¿«ä¹ï¼";
                let i = 0;
                const interval = setInterval(() => {
                    const el = document.getElementById('greeting');
                    if(el) el.innerText = text.slice(0, i);
                    i++;
                    if (i > text.length) clearInterval(interval);
                }, 150);
                return () => clearInterval(interval);
            }, []);
            return null;
        };

        // é›ªèŠ±ç³»ç»Ÿ
        const Snow = ({ count = 1000 }) => {
            const mesh = useRef();
            const [particles] = useMemo(() => {
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    pos.set([(Math.random()-0.5)*30, Math.random()*25, (Math.random()-0.5)*30], i * 3);
                }
                return [pos];
            }, [count]);

            useFrame(() => {
                const positions = mesh.current.geometry.attributes.position.array;
                for (let i = 0; i < count; i++) {
                    positions[i * 3 + 1] -= 0.03;
                    if (positions[i * 3 + 1] < -5) positions[i * 3 + 1] = 20;
                }
                mesh.current.geometry.attributes.position.needsUpdate = true;
            });

            return (
                <points ref={mesh}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={particles} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.06} color="#ffffff" transparent opacity={0.6} />
                </points>
            );
        };

        // ç¤¼ç‰©ç›’ç»„ä»¶
        const GiftBox = ({ position, color, ribbonColor, scale = 1 }) => (
            <group position={position} scale={scale}>
                <mesh castShadow>
                    <boxGeometry args={[1, 1, 1]} />
                    <meshStandardMaterial color={color} roughness={0.5} />
                </mesh>
                <mesh position={[0, 0, 0]}>
                    <boxGeometry args={[1.05, 0.2, 1.05]} />
                    <meshStandardMaterial color={ribbonColor} />
                </mesh>
                <mesh position={[0, 0, 0]} rotation={[0, 0, Math.PI/2]}>
                    <boxGeometry args={[1.05, 0.2, 1.05]} />
                    <meshStandardMaterial color={ribbonColor} />
                </mesh>
            </group>
        );

        // çº¿æ¡å…”å­
        const WireRabbit = ({ isExploded }) => {
            const groupRef = useRef();
            const [data] = useMemo(() => {
                const temp = [];
                for(let i=0; i<6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    temp.push({
                        pos: [Math.cos(angle)*3, -3.8, Math.sin(angle)*3],
                        rot: [0, -angle, 0]
                    });
                }
                return [temp];
            }, []);

            useFrame((state) => {
                if(!isExploded) {
                    groupRef.current.rotation.y += 0.005;
                }
            });

            return (
                <group ref={groupRef} visible={!isExploded}>
                    {data.map((d, i) => (
                        <group key={i} position={d.pos} rotation={d.rot}>
                            <mesh>
                                <icosahedronGeometry args={[0.3, 1]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            <mesh position={[0.1, 0.4, 0]} rotation={[0, 0, 0.2]}>
                                <capsuleGeometry args={[0.05, 0.3, 2, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            <mesh position={[-0.1, 0.4, 0]} rotation={[0, 0, -0.2]}>
                                <capsuleGeometry args={[0.05, 0.3, 2, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                        </group>
                    ))}
                </group>
            );
        };

        // å®ä¾‹åŒ–é‡‘å±çƒ
        const MetallicOrbs = ({ isExploded }) => {
            const meshRef = useRef();
            const dummy = new THREE.Object3D();
            const count = 40;
            const colors = [PALETTE.gold, PALETTE.silver, PALETTE.xmasRed, '#00A86B'];

            const orbs = useMemo(() => {
                const temp = [];
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 0.9) * 9 - 4.5;
                    const r = (5 - y) * 0.4;
                    const angle = Math.random() * Math.PI * 2;
                    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                    temp.push({
                        basePos: pos.clone(),
                        currentPos: pos.clone(),
                        velocity: pos.clone().normalize().multiplyScalar(Math.random() * 10 + 5),
                        color: new THREE.Color(colors[i % colors.length])
                    });
                }
                return temp;
            }, []);

            useFrame((state, delta) => {
                orbs.forEach((o, i) => {
                    if (isExploded) {
                        o.currentPos.addScaledVector(o.velocity, delta * 0.5);
                    } else {
                        o.currentPos.lerp(o.basePos, 0.1);
                    }
                    dummy.position.copy(o.currentPos);
                    dummy.scale.setScalar(1.2);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                    meshRef.current.setColorAt(i, o.color);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                meshRef.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[new THREE.SphereGeometry(0.12, 24, 24), null, count]}>
                    <meshStandardMaterial metalness={1} roughness={0.1} />
                </instancedMesh>
            );
        };

        // æ ‘å¶ç²’å­
        const FoliageLayer = ({ isExploded }) => {
            const count = 4000;
            const meshRef = useRef();
            const pts = useMemo(() => {
                const arr = new Float32Array(count * 3);
                const vels = new Float32Array(count * 3);
                const base = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 1.1) * 10 - 5;
                    const r = (5 - y) * 0.42;
                    const a = Math.random() * Math.PI * 2;
                    const x = Math.cos(a) * r, z = Math.sin(a) * r;
                    arr.set([x, y, z], i * 3); base.set([x, y, z], i * 3);
                    const vel = new THREE.Vector3(x, y, z).normalize().multiplyScalar(Math.random() * 15 + 5);
                    vels.set([vel.x, vel.y, vel.z], i * 3);
                }
                return { arr, vels, base };
            }, []);

            useFrame((state, delta) => {
                const attr = meshRef.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    let x = attr.array[i*3], y = attr.array[i*3+1], z = attr.array[i*3+2];
                    if (isExploded) {
                        x += pts.vels[i*3] * delta * 0.5; y += pts.vels[i*3+1] * delta * 0.5; z += pts.vels[i*3+2] * delta * 0.5;
                    } else {
                        x = THREE.MathUtils.lerp(x, pts.base[i*3], 0.1);
                        y = THREE.MathUtils.lerp(y, pts.base[i*3+1], 0.1);
                        z = THREE.MathUtils.lerp(z, pts.base[i*3+2], 0.1);
                    }
                    attr.setXYZ(i, x, y, z);
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={pts.arr} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.07} color="#165B33" transparent opacity={0.8} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        const App = () => {
            const [exploded, setExploded] = useState(false);

            return (
                <Canvas onClick={() => setExploded(!exploded)}>
                    <Typewriter />
                    <PerspectiveCamera makeDefault position={[0, 2, 16]} fov={45} />
                    <OrbitControls enablePan={false} autoRotate={!exploded} autoRotateSpeed={0.5} minDistance={8} maxDistance={20} />
                    
                    <color attach="background" args={[PALETTE.bg]} />
                    <ambientLight intensity={0.5} />
                    <pointLight position={[10, 10, 10]} intensity={10} color={PALETTE.gold} />
                    <spotLight position={[0, 10, 0]} intensity={5} color="#ffffff" angle={0.5} />

                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade />
                    <Snow count={1200} />

                    <FoliageLayer isExploded={exploded} />
                    <MetallicOrbs isExploded={exploded} />
                    <WireRabbit isExploded={exploded} />

                    {!exploded && (
                        <group position={[0, -4.5, 0]}>
                            <GiftBox position={[2, 0, 1]} color={PALETTE.xmasRed} ribbonColor={PALETTE.gold} scale={0.8} />
                            <GiftBox position={[-1.5, 0, 2]} color="#4169E1" ribbonColor="#ffffff" scale={1} />
                            <GiftBox position={[0.5, 0, -2.5]} color={PALETTE.xmasGreen} ribbonColor={PALETTE.pink} scale={0.7} />
                        </group>
                    )}

                    <Float speed={3} rotationIntensity={2} floatIntensity={1}>
                        <mesh position={[0, 5.4, 0]}>
                            <octahedronGeometry args={[0.5, 0]} />
                            <meshBasicMaterial color={PALETTE.gold} />
                            <pointLight intensity={20} distance={10} color={PALETTE.gold} />
                        </mesh>
                    </Float>

                    <EffectComposer>
                        <Bloom luminanceThreshold={0.2} mipmapBlur intensity={1.5} radius={0.4} />
                        <Vignette offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </Canvas>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
