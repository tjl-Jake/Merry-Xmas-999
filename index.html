<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Fidelity Xmas Tree</title>
    <style>
        body { margin: 0; background: #050a07; overflow: hidden; font-family: -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        .overlay {
            position: absolute; top: 12%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }
        .overlay h1 { color: #FFFACD; text-shadow: 0 0 15px #FADADD; margin: 0; font-size: 26px; }
        .overlay p { color: white; opacity: 0.5; letter-spacing: 5px; font-size: 12px; margin-top: 8px; }
        .hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #C1E1C1; opacity: 0.4; font-size: 11px; letter-spacing: 2px; pointer-events: none;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.15?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div class="overlay">
        <h1>小羊同学，圣诞节快乐！</h1>
        <p>MERRY CHRISTMAS</p>
    </div>
    <div id="root"></div>
    <div class="hint">点击屏幕任意处触发粒子交互</div>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Float, Stars, OrbitControls, PerspectiveCamera } from '@react-three/drei';

        const PALETTE = { green: '#C1E1C1', pink: '#FADADD', gold: '#FFFACD', accent: '#FFB7B2', bg: '#050a07' };

        // --- 通用物理实例化组件 ---
        const OrnamentLayer = ({ count, geometry, color, isExploded, wireframe = false, scale = 1 }) => {
            const meshRef = useRef();
            const dummy = new THREE.Object3D();
            
            // 初始化每个实例的位置和速度
            const particles = useMemo(() => {
                const temp = [];
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 0.9) * 10 - 5;
                    const r = (5 - y) * 0.45;
                    const angle = Math.random() * Math.PI * 2;
                    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                    temp.push({
                        basePos: pos.clone(),
                        baseRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                        currentPos: pos.clone(),
                        currentRot: new THREE.Euler().copy(new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0)),
                        velocity: pos.clone().normalize().multiplyScalar(Math.random() * 12 + 4),
                        angVel: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, 0).multiplyScalar(2)
                    });
                }
                return temp;
            }, [count]);

            useFrame((state, delta) => {
                particles.forEach((p, i) => {
                    if (isExploded) {
                        p.currentPos.addScaledVector(p.velocity, delta * 0.6);
                        p.currentRot.x += p.angVel.x * delta;
                        p.currentRot.y += p.angVel.y * delta;
                        p.velocity.multiplyScalar(0.97);
                    } else {
                        p.currentPos.lerp(p.basePos, 0.1);
                        p.currentRot.x = THREE.MathUtils.lerp(p.currentRot.x, p.baseRot.x, 0.1);
                        p.currentRot.y = THREE.MathUtils.lerp(p.currentRot.y, p.baseRot.y, 0.1);
                    }
                    dummy.position.copy(p.currentPos);
                    dummy.rotation.copy(p.currentRot);
                    dummy.scale.setScalar(scale);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[geometry, null, count]}>
                    <meshStandardMaterial color={color} roughness={0.2} metalness={0.7} wireframe={wireframe} emissive={color} emissiveIntensity={wireframe ? 0.5 : 0.1} />
                </instancedMesh>
            );
        };

        // --- 针叶层 (Shader粒子) ---
        const FoliageLayer = ({ isExploded }) => {
            const count = 3500;
            const meshRef = useRef();
            const pts = useMemo(() => {
                const arr = new Float32Array(count * 3);
                const vels = new Float32Array(count * 3);
                const base = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 1.1) * 10 - 5;
                    const r = (5 - y) * 0.42;
                    const a = Math.random() * Math.PI * 2;
                    const x = Math.cos(a) * r, z = Math.sin(a) * r;
                    arr.set([x, y, z], i * 3);
                    base.set([x, y, z], i * 3);
                    const vel = new THREE.Vector3(x, y, z).normalize().multiplyScalar(Math.random() * 15 + 5);
                    vels.set([vel.x, vel.y, vel.z], i * 3);
                }
                return { arr, vels, base };
            }, []);

            useFrame((state, delta) => {
                const attr = meshRef.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    let x = attr.array[i*3], y = attr.array[i*3+1], z = attr.array[i*3+2];
                    if (isExploded) {
                        x += pts.vels[i*3] * delta * 0.5;
                        y += pts.vels[i*3+1] * delta * 0.5;
                        z += pts.vels[i*3+2] * delta * 0.5;
                    } else {
                        x = THREE.MathUtils.lerp(x, pts.base[i*3], 0.1);
                        y = THREE.MathUtils.lerp(y, pts.base[i*3+1], 0.1);
                        z = THREE.MathUtils.lerp(z, pts.base[i*3+2], 0.1);
                    }
                    attr.setXYZ(i, x, y, z);
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={pts.arr} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.05} color={PALETTE.green} transparent opacity={0.6} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        const App = () => {
            const [exploded, setExploded] = useState(false);
            
            // 复用几何体
            const boxGeo = useMemo(() => new THREE.BoxGeometry(0.25, 0.25, 0.25), []);
            const sphereGeo = useMemo(() => new THREE.SphereGeometry(0.12, 16, 16), []);
            const rabbitGeo = useMemo(() => new THREE.IcosahedronGeometry(0.2, 1), []);

            return (
                <Canvas onClick={() => setExploded(!exploded)}>
                    <PerspectiveCamera makeDefault position={[0, 2, 14]} fov={45} />
                    <OrbitControls enablePan={false} autoRotate={!exploded} autoRotateSpeed={0.5} />
                    <color attach="background" args={[PALETTE.bg]} />
                    
                    <ambientLight intensity={0.4} />
                    <pointLight position={[10, 10, 10]} intensity={2} color={PALETTE.pink} />
                    <spotLight position={[0, 10, 0]} intensity={1} color={PALETTE.gold} />

                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
                    
                    {/* 树的主体 */}
                    <FoliageLayer isExploded={exploded} />

                    {/* 额外元素层 */}
                    <OrnamentLayer count={40} geometry={boxGeo} color={PALETTE.accent} isExploded={exploded} scale={1.2} />
                    <OrnamentLayer count={60} geometry={sphereGeo} color={PALETTE.gold} isExploded={exploded} />
                    <OrnamentLayer count={25} geometry={rabbitGeo} color={PALETTE.pink} isExploded={exploded} wireframe={true} scale={1.6} />

                    {/* 顶部的星星 */}
                    <Float speed={3} rotationIntensity={1} floatIntensity={1}>
                        <mesh position={[0, 5.5, 0]}>
                            <octahedronGeometry args={[0.4, 0]} />
                            <meshBasicMaterial color={PALETTE.gold} />
                        </mesh>
                    </Float>
                </Canvas>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
