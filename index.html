<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Fidelity Xmas Tree</title>
    <style>
        body { margin: 0; background: #020504; overflow: hidden; font-family: -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        .overlay {
            position: absolute; top: 10%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }
        .overlay h1 { color: #FFFACD; text-shadow: 0 0 20px rgba(255,250,205,0.8); margin: 0; font-size: 28px; min-height: 1.2em; }
        .overlay p { color: white; opacity: 0.6; letter-spacing: 5px; font-size: 12px; margin-top: 10px; }
        .hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #C1E1C1; opacity: 0.5; font-size: 11px; letter-spacing: 2px; pointer-events: none;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom": "https://esm.sh/react-dom@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.15?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.15.11?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>

<body>

    <div id="start-overlay">
        <div class="start-content">
            <div class="tap-icon">ğŸ‘†</div>
            <h1>ç‚¹å‡»å±å¹•å¼€å¯</h1>
            <p>ä½©æˆ´è€³æœºä½“éªŒæ›´ä½³</p>
        </div>
    </div>

    <div id="bgm-player" class="player-hidden">
        <div class="player-content">
            <div class="visualizer">
                <span></span><span></span><span></span><span></span>
            </div>
            <div class="track-info">
                <span id="music-status">æ­£åœ¨æ’­æ”¾</span>
            </div>
            <button id="toggle-btn" class="icon-btn">â¸</button>
        </div>
        
        <audio id="bgm-audio" loop playsinline>
            <source src="music.mp3" type="audio/mpeg">
        </audio>
    </div>

    <style>
        /* æ‰‹æœºé€‚é…æ ·å¼ */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
            color: white;
            touch-action: manipulation; /* ä¼˜åŒ–è§¦å±å“åº” */
        }
        .start-content { text-align: center; }
        .tap-icon { font-size: 40px; animation: bounce 1s infinite; margin-bottom: 20px; }
        
        #bgm-player {
            position: fixed;
            bottom: 20px; /* æ‰‹æœºä¸Šç¨å¾®é ä¸Šä¸€ç‚¹ï¼Œé¿å¼€é»‘æ¡ */
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            width: 85%; /* æ‰‹æœºä¸Šå®½åº¦è®¾ä¸ºç™¾åˆ†æ¯” */
            max-width: 350px;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.27);
        }

        .player-hidden { transform: translate(-50%, 200%) !important; }

        .player-content {
            display: flex; align-items: center; justify-content: space-between;
            background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%);
            padding: 12px 20px;
            border-radius: 50px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.4);
        }

        .icon-btn {
            background: rgba(255, 255, 255, 0.3);
            border: none; border-radius: 50%;
            width: 40px; height: 40px;
            color: white; font-size: 18px;
        }

        .visualizer { display: flex; gap: 3px; height: 15px; align-items: flex-end; }
        .visualizer span { width: 3px; background: white; animation: bounceVisual 1s infinite ease-in-out; }
        @keyframes bounceVisual { 0%, 100% { height: 20%; } 50% { height: 100%; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    </style>

    <script>
        (function() {
            const overlay = document.getElementById('start-overlay');
            const player = document.getElementById('bgm-player');
            const audio = document.getElementById('bgm-audio');
            const btn = document.getElementById('toggle-btn');

            function startPlay() {
    // 1. å…ˆä¸ç®¡éŸ³ä¹å¥½åï¼Œç›´æ¥ç§»é™¤é®ç½©å±‚ï¼Œè®©ä½ æœ‹å‹èƒ½çœ‹åˆ°ç”»é¢
    overlay.style.opacity = '0';
    setTimeout(() => overlay.remove(), 800);
    player.classList.remove('player-hidden');

    // 2. å°è¯•æ’­æ”¾éŸ³ä¹
    audio.play().catch(err => {
        console.log("éŸ³ä¹æ’­æ”¾å¤±è´¥ï¼ˆå¯èƒ½æ˜¯404æˆ–è¢«æ‹¦æˆªï¼‰ï¼Œä½†ä¸å½±å“ç”»é¢æ˜¾ç¤º");
    });
}

            // åŒæ—¶ç›‘å¬ç‚¹å‡»å’Œè§¦æ‘¸ï¼Œç¡®ä¿æ‰‹æœºèƒ½ååº”
            overlay.addEventListener('click', startPlay);
            overlay.addEventListener('touchstart', startPlay, {passive: false});

            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // é˜²æ­¢è¯¯è§¦
                if (audio.paused) {
                    audio.play();
                    btn.textContent = 'â¸';
                } else {
                    audio.pause();
                    btn.textContent = 'â–¶';
                }
            });
        })();
    </script>
</body>
    
    <div class="overlay">
        <h1 id="greeting"></h1>
        <p>MERRY CHRISTMAS</p>
    </div>
    <div id="root"></div>
    <div class="hint">äººç”Ÿä¸è¿‡ä¸‰ä¸‡å¤© æˆ‘æ„¿çˆ±ä½ ä¸‰ä¸‡é</div>

    <script type="text/babel" data-type="module">
        /** @jsx React.createElement */
        /** @jsxFrag React.Fragment */
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Float, Stars, OrbitControls, PerspectiveCamera, MeshWobbleMaterial } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

        // è°ƒè‰²æ¿
        const PALETTE = {
            green: '#1A3317', 
            gold: '#FFD700', 
            silver: '#E5E4E2',
            xmasRed: '#D42426',
            xmasGreen: '#165B33',
            pink: '#FFB7B2',
            bg: '#020504'
        };

        // æ‰“å­—æœºæ•ˆæœ
        const Typewriter = () => {
            useEffect(() => {
                const text = "å°ç¾ŠåŒå­¦ï¼Œåœ£è¯èŠ‚å¿«ä¹ï¼";
                let i = 0;
                const interval = setInterval(() => {
                    const el = document.getElementById('greeting');
                    if(el) el.innerText = text.slice(0, i);
                    i++;
                    if (i > text.length) clearInterval(interval);
                }, 150);
                return () => clearInterval(interval);
            }, []);
            return null;
        };

        // é›ªèŠ±ç³»ç»Ÿ
        const Snow = ({ count = 1000 }) => {
            const mesh = useRef();
            const [particles] = useMemo(() => {
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    pos.set([(Math.random()-0.5)*30, Math.random()*25, (Math.random()-0.5)*30], i * 3);
                }
                return [pos];
            }, [count]);

            useFrame(() => {
                const positions = mesh.current.geometry.attributes.position.array;
                for (let i = 0; i < count; i++) {
                    positions[i * 3 + 1] -= 0.03;
                    if (positions[i * 3 + 1] < -5) positions[i * 3 + 1] = 20;
                }
                mesh.current.geometry.attributes.position.needsUpdate = true;
            });

            return (
                <points ref={mesh}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={particles} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.06} color="#ffffff" transparent opacity={0.6} />
                </points>
            );
        };

        // ç¤¼ç‰©ç›’ç»„ä»¶
        const GiftBox = ({ position, color, ribbonColor, scale = 1 }) => (
            <group position={position} scale={scale}>
                <mesh castShadow>
                    <boxGeometry args={[1, 1, 1]} />
                    <meshStandardMaterial color={color} roughness={0.5} />
                </mesh>
                <mesh position={[0, 0, 0]}>
                    <boxGeometry args={[1.05, 0.2, 1.05]} />
                    <meshStandardMaterial color={ribbonColor} />
                </mesh>
                <mesh position={[0, 0, 0]} rotation={[0, 0, Math.PI/2]}>
                    <boxGeometry args={[1.05, 0.2, 1.05]} />
                    <meshStandardMaterial color={ribbonColor} />
                </mesh>
            </group>
        );

        // çº¿æ¡å…”å­ (å‡ ä½•é£æ ¼)
        const WireRabbit = ({ isExploded }) => {
            const groupRef = useRef();
            const [data] = useMemo(() => {
                const temp = [];
                for(let i=0; i<6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    temp.push({
                        pos: [Math.cos(angle)*3, -3.8, Math.sin(angle)*3],
                        rot: [0, -angle, 0]
                    });
                }
                return [temp];
            }, []);

            useFrame((state) => {
                if(!isExploded) {
                    groupRef.current.rotation.y += 0.005;
                }
            });

            return (
                <group ref={groupRef} visible={!isExploded}>
                    {data.map((d, i) => (
                        <group key={i} position={d.pos} rotation={d.rot}>
                            {/* å…”å­èº«ä½“ */}
                            <mesh>
                                <icosahedronGeometry args={[0.3, 1]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            {/* å…”å­è€³æœµ */}
                            <mesh position={[0.1, 0.4, 0]} rotation={[0, 0, 0.2]}>
                                <capsuleGeometry args={[0.05, 0.3, 2, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                            <mesh position={[-0.1, 0.4, 0]} rotation={[0, 0, -0.2]}>
                                <capsuleGeometry args={[0.05, 0.3, 2, 8]} />
                                <meshBasicMaterial color={PALETTE.pink} wireframe />
                            </mesh>
                        </group>
                    ))}
                </group>
            );
        };

        // å®ä¾‹åŒ–é‡‘å±çƒ
        const MetallicOrbs = ({ isExploded }) => {
            const meshRef = useRef();
            const dummy = new THREE.Object3D();
            const count = 40;
            const colors = [PALETTE.gold, PALETTE.silver, PALETTE.xmasRed, '#00A86B'];

            const orbs = useMemo(() => {
                const temp = [];
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 0.9) * 9 - 4.5;
                    const r = (5 - y) * 0.4;
                    const angle = Math.random() * Math.PI * 2;
                    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                    temp.push({
                        basePos: pos.clone(),
                        currentPos: pos.clone(),
                        velocity: pos.clone().normalize().multiplyScalar(Math.random() * 10 + 5),
                        color: new THREE.Color(colors[i % colors.length])
                    });
                }
                return temp;
            }, []);

            useFrame((state, delta) => {
                orbs.forEach((o, i) => {
                    if (isExploded) {
                        o.currentPos.addScaledVector(o.velocity, delta * 0.5);
                    } else {
                        o.currentPos.lerp(o.basePos, 0.1);
                    }
                    dummy.position.copy(o.currentPos);
                    dummy.scale.setScalar(1.2);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                    meshRef.current.setColorAt(i, o.color);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                meshRef.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[new THREE.SphereGeometry(0.12, 24, 24), null, count]}>
                    <meshStandardMaterial metalness={1} roughness={0.1} />
                </instancedMesh>
            );
        };

        // æ ‘å¶ç²’å­
        const FoliageLayer = ({ isExploded }) => {
            const count = 4000;
            const meshRef = useRef();
            const pts = useMemo(() => {
                const arr = new Float32Array(count * 3);
                const vels = new Float32Array(count * 3);
                const base = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    const y = Math.pow(Math.random(), 1.1) * 10 - 5;
                    const r = (5 - y) * 0.42;
                    const a = Math.random() * Math.PI * 2;
                    const x = Math.cos(a) * r, z = Math.sin(a) * r;
                    arr.set([x, y, z], i * 3); base.set([x, y, z], i * 3);
                    const vel = new THREE.Vector3(x, y, z).normalize().multiplyScalar(Math.random() * 15 + 5);
                    vels.set([vel.x, vel.y, vel.z], i * 3);
                }
                return { arr, vels, base };
            }, []);

            useFrame((state, delta) => {
                const attr = meshRef.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    let x = attr.array[i*3], y = attr.array[i*3+1], z = attr.array[i*3+2];
                    if (isExploded) {
                        x += pts.vels[i*3] * delta * 0.5; y += pts.vels[i*3+1] * delta * 0.5; z += pts.vels[i*3+2] * delta * 0.5;
                    } else {
                        x = THREE.MathUtils.lerp(x, pts.base[i*3], 0.1);
                        y = THREE.MathUtils.lerp(y, pts.base[i*3+1], 0.1);
                        z = THREE.MathUtils.lerp(z, pts.base[i*3+2], 0.1);
                    }
                    attr.setXYZ(i, x, y, z);
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={pts.arr} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.07} color="#165B33" transparent opacity={0.8} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        const App = () => {
            const [exploded, setExploded] = useState(false);

            return (
                <Canvas onClick={() => setExploded(!exploded)}>
                    <Typewriter />
                    <PerspectiveCamera makeDefault position={[0, 2, 16]} fov={45} />
                    <OrbitControls enablePan={false} autoRotate={!exploded} autoRotateSpeed={0.5} minDistance={8} maxDistance={20} />
                    
                    <color attach="background" args={[PALETTE.bg]} />
                    <ambientLight intensity={0.5} />
                    <pointLight position={[10, 10, 10]} intensity={10} color={PALETTE.gold} />
                    <spotLight position={[0, 10, 0]} intensity={5} color="#ffffff" angle={0.5} />

                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade />
                    <Snow count={1200} />

                    <FoliageLayer isExploded={exploded} />
                    <MetallicOrbs isExploded={exploded} />
                    <WireRabbit isExploded={exploded} />

                    {/* æ ‘ä¸‹çš„ç¤¼ç‰©ç›’ */}
                    {!exploded && (
                        <group position={[0, -4.5, 0]}>
                            <GiftBox position={[2, 0, 1]} color={PALETTE.xmasRed} ribbonColor={PALETTE.gold} scale={0.8} />
                            <GiftBox position={[-1.5, 0, 2]} color="#4169E1" ribbonColor="#ffffff" scale={1} />
                            <GiftBox position={[0.5, 0, -2.5]} color={PALETTE.xmasGreen} ribbonColor={PALETTE.pink} scale={0.7} />
                        </group>
                    )}

                    {/* é¡¶éƒ¨å‘å…‰æ˜Ÿ */}
                    <Float speed={3} rotationIntensity={2} floatIntensity={1}>
                        <mesh position={[0, 5.4, 0]}>
                            <octahedronGeometry args={[0.5, 0]} />
                            <meshBasicMaterial color={PALETTE.gold} />
                            <pointLight intensity={20} distance={10} color={PALETTE.gold} />
                        </mesh>
                    </Float>

                    <EffectComposer>
                        <Bloom luminanceThreshold={0.2} mipmapBlur intensity={1.5} radius={0.4} />
                        <Vignette offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </Canvas>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
